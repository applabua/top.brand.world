<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Million Mosaic — Plain (10k demo)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  /* Page: pure white, no UI */
  html, body { margin:0; padding:0; height:100%; background:#fff; overflow:hidden; }
  #field { display:block; width:100vw; height:100vh; cursor:crosshair; }

  /* Modal (minimal) */
  .overlay {
    position:fixed; inset:0; background:rgba(0,0,0,0.4);
    display:none; align-items:center; justify-content:center;
  }
  .overlay.on { display:flex; }
  .modal {
    width:min(560px, 92vw); background:#fff; border:1px solid #ddd; border-radius:12px;
    box-shadow:0 10px 40px rgba(0,0,0,.25); padding:16px;
    font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color:#111;
  }
  .modal h2 { margin:0 0 8px 0; font-size:18px; }
  .modal .price { margin:0 0 12px 0; color:#444; }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .drop {
    width:100%; min-height:120px; border:1px dashed #bbb; border-radius:10px;
    display:flex; align-items:center; justify-content:center; padding:10px; color:#666;
  }
  .thumb { max-width:100%; max-height:200px; margin-top:8px; border-radius:8px; border:1px solid #eee; }
  .actions { display:flex; gap:8px; justify-content:flex-end; margin-top:14px; }
  .btn {
    appearance:none; border:1px solid #ccc; background:#fff; color:#111; padding:8px 12px;
    border-radius:10px; cursor:pointer;
  }
  .btn.primary { background:#111; color:#fff; border-color:#111; }
  .btn[disabled] { opacity:.5; cursor:not-allowed; }
  .mini { font-size:12px; color:#666; }
</style>
</head>
<body>

<canvas id="field"></canvas>

<!-- Minimal modal (demo add, no payment) -->
<div class="overlay" id="overlay">
  <div class="modal" role="dialog" aria-modal="true">
    <h2 id="mTitle">Cell</h2>
    <p class="price" id="mPrice">$ —</p>

    <div class="row">
      <div class="drop" id="drop">
        <input type="file" id="file" accept="image/*" style="display:none">
        <span id="dropText">Drop your ad image here (or click)</span>
      </div>
      <img id="preview" class="thumb" alt="" style="display:none">
    </div>

    <div class="actions">
      <button class="btn" id="closeBtn">Close</button>
      <button class="btn primary" id="saveBtn" disabled>Save (demo)</button>
    </div>
    <div class="mini">Demo only: your image is rendered locally into the chosen cell (no payment, no upload).</div>
  </div>
</div>

<script>
/* ====== Config (you can change) ====== */
const CELL_COUNT = 10000;           // 10,000 cells
const WORLD_W = 4000, WORLD_H = 2600; // virtual world size
const LINE_COLOR = '#d8d8d8';       // borders (light gray)
const LINE_WIDTH = 1;
const MIN_SIZE = 18;                // avoid long skinny strips
const TEN_DOLLAR_SHARE = 0.08;      // ~8% of cells near center & larger => $10

/* ====== Utilities ====== */
const rnd = (a=0, b=1) => a + Math.random()*(b-a);
function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
function makeRect(x,y,w,h){ return {x,y,w,h, area:w*h}; }
function canSplit(r){
  return (r.w >= MIN_SIZE*2) || (r.h >= MIN_SIZE*2);
}

/* ====== Treemap-like random split to N rectangles (chaotic but bounded AR) ====== */
function splitRect(r){
  // Choose orientation (slight bias to longer side, but allow chaos)
  const bias = r.w > r.h ? 0.6 : 0.4;
  let horiz = Math.random() < bias;

  // Ensure we pick an orientation that can meet MIN_SIZE for both children
  if (horiz && r.w < MIN_SIZE*2) horiz = false;
  if (!horiz && r.h < MIN_SIZE*2) {
    if (r.w >= MIN_SIZE*2) horiz = true; else return null;
  }

  if (horiz){
    const minCut = MIN_SIZE, maxCut = r.w - MIN_SIZE;
    if (maxCut <= minCut) return null;
    // 60% balanced, 40% chaotic (but clamped by MIN_SIZE)
    const ratio = (Math.random() < 0.6) ? rnd(0.42, 0.58) : rnd(0.25, 0.75);
    const cut = clamp(Math.round(r.w * ratio), minCut, maxCut);
    const a = makeRect(r.x, r.y, cut, r.h);
    const b = makeRect(r.x + cut, r.y, r.w - cut, r.h);
    return [a,b];
  } else {
    const minCut = MIN_SIZE, maxCut = r.h - MIN_SIZE;
    if (maxCut <= minCut) return null;
    const ratio = (Math.random() < 0.6) ? rnd(0.42, 0.58) : rnd(0.25, 0.75);
    const cut = clamp(Math.round(r.h * ratio), minCut, maxCut);
    const a = makeRect(r.x, r.y, r.w, cut);
    const b = makeRect(r.x, r.y + cut, r.w, r.h - cut);
    return [a,b];
  }
}

function buildLayout(count){
  const list = [ makeRect(0,0, WORLD_W, WORLD_H) ];
  while (list.length < count) {
    // pick largest area rect that can split
    let idx = -1, bestArea = -1;
    for (let i=0;i<list.length;i++){
      const r = list[i];
      if (canSplit(r) && r.area > bestArea){ bestArea = r.area; idx = i; }
    }
    if (idx === -1) break;
    const r = list.splice(idx,1)[0];
    const parts = splitRect(r);
    if (!parts){ /* can't split this one: lock it back and try next largest */ list.push(r); 
      // mark it as unsplittable by zeroing area so it won't be picked again
      r.area = -1; 
      continue; 
    }
    list.push(parts[0], parts[1]);
  }
  list.forEach((r,i)=>{ r.id = i; r.area = r.w*r.h; });
  return list;
}

/* ====== Pricing: only $1 or $10 (bigger & more central -> $10) ====== */
function assignPrices(cells){
  // score = (area/maxArea) * centrality(0..1), then top ~8% => $10
  let maxA = 0; for (const r of cells) maxA = Math.max(maxA, r.area);
  const cx = WORLD_W/2, cy = WORLD_H/2;
  const maxD = Math.hypot(cx, cy); // corner distance upper bound
  const scored = cells.map(r=>{
    const rcx = r.x + r.w/2, rcy = r.y + r.h/2;
    const centrality = 1 - (Math.hypot(rcx - cx, rcy - cy) / maxD);
    const score = (r.area / maxA) * centrality;
    return {r, score};
  }).sort((a,b)=> b.score - a.score);

  const tenCount = Math.max(1, Math.floor(cells.length * TEN_DOLLAR_SHARE));
  const tenSet = new Set(scored.slice(0, tenCount).map(o=>o.r.id));
  for (const r of cells){
    r.price = tenSet.has(r.id) ? 10 : 1;
  }
}

/* ====== Rendering & hit-testing ====== */
const canvas = document.getElementById('field');
const ctx = canvas.getContext('2d');

let DPR = Math.max(1, window.devicePixelRatio || 1);
let W = 0, H = 0;
let layout = buildLayout(CELL_COUNT);
assignPrices(layout);

/* Build a simple spatial grid index for fast hit-tests (10k cells) */
const GS = 64; // world grid size in px
const GX = Math.ceil(WORLD_W / GS), GY = Math.ceil(WORLD_H / GS);
const grid = Array.from({length: GY}, ()=> Array.from({length: GX}, ()=> []));
for (const r of layout){
  const gx0 = Math.floor(r.x / GS), gy0 = Math.floor(r.y / GS);
  const gx1 = Math.floor((r.x + r.w) / GS), gy1 = Math.floor((r.y + r.h) / GS);
  for (let gy=gy0; gy<=gy1; gy++){
    for (let gx=gx0; gx<=gx1; gx++){
      if (grid[gy] && grid[gy][gx]) grid[gy][gx].push(r);
    }
  }
}

function fitViewport(){
  W = Math.floor(window.innerWidth * DPR);
  H = Math.floor(window.innerHeight * DPR);
  canvas.width = W; canvas.height = H;
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
}

function baseDraw(){
  // compute scale to fit world entirely (fixed, centered)
  const scale = Math.min(W / WORLD_W, H / WORLD_H);
  const ox = (W - WORLD_W*scale)/2;
  const oy = (H - WORLD_H*scale)/2;

  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,W,H);

  ctx.save();
  ctx.translate(ox, oy);
  ctx.scale(scale, scale);
  ctx.lineWidth = Math.max(1, LINE_WIDTH * DPR / scale);
  ctx.strokeStyle = LINE_COLOR;

  // draw all borders
  for (const r of layout){
    ctx.beginPath();
    ctx.rect(r.x, r.y, r.w, r.h);
    ctx.stroke();
  }

  // draw any saved images (after borders we'll re-stroke cell border)
  for (const id in cellImages){
    const r = layout[id|0];
    const img = cellImages[id];
    if (r && img && img.complete) drawImageInRect(ctx, img, r);
    // border on top so grid remains visible
    ctx.beginPath();
    ctx.rect(r.x, r.y, r.w, r.h);
    ctx.stroke();
  }

  ctx.restore();

  // store transform for hit tests & later drawing
  baseDraw._scale = scale; baseDraw._ox = ox; baseDraw._oy = oy;
}

function worldPoint(clientX, clientY){
  const sx = clientX * DPR, sy = clientY * DPR;
  const worldX = (sx - baseDraw._ox) / baseDraw._scale;
  const worldY = (sy - baseDraw._oy) / baseDraw._scale;
  return {worldX, worldY};
}

function hitTest(clientX, clientY){
  const {worldX, worldY} = worldPoint(clientX, clientY);
  if (worldX < 0 || worldY < 0 || worldX > WORLD_W || worldY > WORLD_H) return null;
  const gx = Math.floor(worldX / GS), gy = Math.floor(worldY / GS);
  const bucket = (grid[gy] && grid[gy][gx]) ? grid[gy][gx] : null;
  if (!bucket) return null;
  for (let i=0;i<bucket.length;i++){
    const r = bucket[i];
    if (worldX >= r.x && worldX <= r.x + r.w && worldY >= r.y && worldY <= r.y + r.h) return r;
  }
  return null;
}

window.addEventListener('resize', ()=>{ fitViewport(); baseDraw(); });
fitViewport(); baseDraw();

/* ====== Demo "save" of an image inside a cell (no backend) ====== */
const overlay = document.getElementById('overlay');
const mTitle = document.getElementById('mTitle');
const mPrice = document.getElementById('mPrice');
const closeBtn = document.getElementById('closeBtn');
const saveBtn = document.getElementById('saveBtn');
const drop = document.getElementById('drop');
const fileInput = document.getElementById('file');
const preview = document.getElementById('preview');
const dropText = document.getElementById('dropText');

let currentCell = null;
const cellImages = {}; // id -> HTMLImageElement

canvas.addEventListener('click', (e)=>{
  const r = hitTest(e.clientX, e.clientY);
  if (!r) return;
  currentCell = r;
  mTitle.textContent = `Cell #${r.id}`;
  mPrice.textContent = `$${r.price}`; // no "/ 1 year" text
  preview.style.display = 'none';
  preview.src = '';
  dropText.textContent = 'Drop your ad image here (or click)';
  saveBtn.disabled = true;
  overlay.classList.add('on');
});

closeBtn.addEventListener('click', ()=> overlay.classList.remove('on'));
overlay.addEventListener('click', (e)=>{ if (e.target === overlay) overlay.classList.remove('on'); });
document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') overlay.classList.remove('on'); });

drop.addEventListener('click', ()=> fileInput.click());
drop.addEventListener('dragover', (e)=>{ e.preventDefault(); drop.style.borderColor='#888'; });
drop.addEventListener('dragleave', ()=>{ drop.style.borderColor='#bbb'; });
drop.addEventListener('drop', (e)=>{
  e.preventDefault();
  drop.style.borderColor='#bbb';
  if (e.dataTransfer.files && e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
});
fileInput.addEventListener('change', (e)=>{
  if (e.target.files && e.target.files[0]) handleFile(e.target.files[0]);
});

function handleFile(file){
  if (!/^image\//.test(file.type)) { alert('Please choose an image file'); return; }
  const r = new FileReader();
  r.onload = ()=> {
    preview.src = r.result;
    preview.style.display = 'block';
    dropText.textContent = 'Image selected';
    saveBtn.disabled = false;
  };
  r.readAsDataURL(file);
}

saveBtn.addEventListener('click', ()=>{
  if (!currentCell || !preview.src) return;
  const img = new Image();
  img.onload = ()=>{
    cellImages[currentCell.id] = img;
    drawCellImage(currentCell, img);
    overlay.classList.remove('on');
  };
  img.src = preview.src; // data URL
});

/* draw a single cell image in-place without redrawing everything */
function drawCellImage(r, img){
  const scale = baseDraw._scale, ox = baseDraw._ox, oy = baseDraw._oy;

  // transform to screen
  ctx.save();
  ctx.translate(ox, oy);
  ctx.scale(scale, scale);

  drawImageInRect(ctx, img, r);

  // stroke border on top to keep grid crisp
  ctx.beginPath();
  ctx.rect(r.x, r.y, r.w, r.h);
  ctx.lineWidth = Math.max(1, LINE_WIDTH * DPR / scale);
  ctx.strokeStyle = LINE_COLOR;
  ctx.stroke();

  ctx.restore();
}

/* helper: cover-fit image to rect (centered) */
function drawImageInRect(ctx2d, img, r){
  const iw = img.naturalWidth || img.width;
  const ih = img.naturalHeight || img.height;
  const sx = Math.max(r.w/iw, r.h/ih); // cover
  const dw = iw * sx, dh = ih * sx;
  const dx = r.x + (r.w - dw)/2;
  const dy = r.y + (r.h - dh)/2;
  ctx2d.drawImage(img, dx, dy, dw, dh);
}

/* Note: hover highlight removed for performance with 10k cells */
</script>
</body>
</html>
